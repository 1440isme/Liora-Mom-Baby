<div th:fragment="chat-ws-button">
  <style>
    /* Floating Button Animation */
    .chat-float-btn {
      position: fixed;
      bottom: 150px;
      right: 20px;
      z-index: 9999;
    }
    
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 4px 20px rgba(215, 141, 160, 0.4);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 6px 25px rgba(215, 141, 160, 0.6);
      }
    }
    
    .chat-float-btn button {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, #d78da0 0%, #e8a2b0 100%);
      border: none;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(215, 141, 160, 0.4);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .chat-unread-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #ff4757;
      color: #fff;
      border-radius: 50%;
      min-width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 700;
      padding: 0 6px;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(255, 71, 87, 0.4);
      animation: pulse-badge 2s infinite;
      z-index: 10000;
    }
    
    @keyframes pulse-badge {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
    }
    
    .chat-float-btn button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 25px rgba(215, 141, 160, 0.6);
    }
    
    .chat-float-btn button i {
      font-size: 1.5rem;
      color: white;
    }
    
    /* Chat Box Styles */
    #chatBox {
      font-family: 'Nunito', sans-serif;
      animation: slideUp 0.3s ease;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Custom Scrollbar */
    #chatContent::-webkit-scrollbar {
      width: 6px;
    }
    #chatContent::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    #chatContent::-webkit-scrollbar-thumb {
      background: #d78da0;
      border-radius: 10px;
    }
    #chatContent::-webkit-scrollbar-thumb:hover {
      background: #b85c7a;
    }
    
    /* Message Animation */
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .message-item {
      animation: slideIn 0.3s ease;
    }
  </style>
  
  <!-- Floating Chat Button -->
  <div class="chat-float-btn">
    <button
      class="btn rounded-circle shadow-lg"
      onclick="toggleChatWS()"
      id="chatFloatButton"
    >
      <i class="fas fa-headset"></i>
    </button>
    <span class="chat-unread-badge" id="chatUnreadBadge" style="display: none;">0</span>
  </div>

  <!-- Floating Chat Box -->
  <div
    id="chatBox"
    style="
      display: none;
      position: fixed;
      bottom: 90px;
      right: 90px;
      width: 380px;
      height: 520px;
      max-height: 80vh;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(215, 141, 160, 0.3);
      z-index: 9999;
      overflow: hidden;
      font-family: 'Nunito', sans-serif;
    "
  >
    <!-- Header -->
    <div
      style="
        background: linear-gradient(90deg, #d78da0 0%, #e8a2b0 100%);
        color: white;
        padding: 20px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 2px 8px rgba(215, 141, 160, 0.2);
      "
    >
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background: rgba(255, 255, 255, 0.2);
          display: flex;
          align-items: center;
          justify-content: center;
          border: 2px solid rgba(255, 255, 255, 0.3);
        ">
          <i class="fas fa-spa" style="font-size: 1.2rem;"></i>
        </div>
        <div>
          <div style="font-size: 1.1rem; font-weight: 700;">Liora CSKH</div>
          <div style="font-size: 0.85rem; opacity: 0.9;">H·ªó tr·ª£ tr·ª±c tuy·∫øn</div>
        </div>
      </div>
      <button
        type="button"
        onclick="closeChatWS()"
        style="
          background: rgba(255, 255, 255, 0.2);
          border: none;
          color: white;
          font-size: 24px;
          width: 32px;
          height: 32px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s;
        "
        onmouseover="this.style.background='rgba(255,255,255,0.3)'"
        onmouseout="this.style.background='rgba(255,255,255,0.2)'"
      >
        √ó
      </button>
    </div>

    <!-- Chat content -->
    <div
      id="chatContent"
      style="
        height: calc(520px - 140px);
        max-height: calc(80vh - 140px);
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px;
        background: #f8f9fa;
        display: flex;
        flex-direction: column;
        gap: 12px;
      "
    ></div>

    <!-- Input area -->
    <div
      style="
        padding: 16px 20px;
        border-top: 1px solid #f5d7db;
        background: white;
        display: flex;
        align-items: center;
        gap: 12px;
      "
    >
      <input
        id="chatInput"
        class="form-control"
        placeholder="Nh·∫≠p tin nh·∫Øn..."
        onkeydown="if(event.key==='Enter') sendMessage()"
        style="
          border-radius: 24px;
          border: 2px solid #f5d7db;
          padding: 10px 18px;
          font-size: 0.9rem;
          flex: 1;
          transition: all 0.2s;
        "
        onfocus="this.style.borderColor='#d78da0'"
        onblur="this.style.borderColor='#f5d7db'"
      />

      <button
        class="btn rounded-circle d-flex align-items-center justify-content-center"
        onclick="sendMessage()"
        style="
          background: linear-gradient(135deg, #d78da0 0%, #e8a2b0 100%);
          width: 44px;
          height: 44px;
          border: none;
          box-shadow: 0 2px 8px rgba(215, 141, 160, 0.3);
          transition: all 0.2s;
        "
        onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 12px rgba(215, 141, 160, 0.4)'"
        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(215, 141, 160, 0.3)'"
      >
        <i class="fas fa-paper-plane text-white" style="font-size: 0.9rem;"></i>
      </button>
    </div>
  </div>

  <!-- JS ph·∫£i N·∫∞M TRONG fragment -->
  <script th:inline="javascript">
    let socket = null;
    let isConnected = false;
    let hasShownWelcome = false;
    let pendingMessages = new Map(); // Track messages ƒëang ch·ªù server response (key: content+timestamp, value: element)
    let renderedMessageIds = new Set(); // Track messages ƒë√£ render ƒë·ªÉ tr√°nh duplicate
    let unreadCount = 0; // S·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc

    // H√†m c·∫≠p nh·∫≠t badge s·ªë ƒë·∫øm
    function updateUnreadBadge() {
      const badge = document.getElementById("chatUnreadBadge");
      if (badge) {
        if (unreadCount > 0) {
          badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
          badge.style.display = 'flex';
        } else {
          badge.style.display = 'none';
        }
      }
    }

    // TƒÉng unread count
    function incrementUnreadCount() {
      unreadCount++;
      updateUnreadBadge();
    }

    // Reset unread count
    function resetUnreadCount() {
      unreadCount = 0;
      updateUnreadBadge();
    }

    function toggleChatWS() {
      // Ki·ªÉm tra ƒëƒÉng nh·∫≠p t·ª´ localStorage (gi·ªëng header)
      const userData = localStorage.getItem("liora_user");
      const accessToken = localStorage.getItem("access_token");
      if (!userData || !accessToken) {
        // Ch∆∞a ƒëƒÉng nh·∫≠p, m·ªü modal ƒëƒÉng nh·∫≠p
        if (window.bootstrap && document.getElementById("authModal")) {
          const modal = new bootstrap.Modal(
            document.getElementById("authModal")
          );
          modal.show();
        } else if (window.$ && $("#authModal").modal) {
          // N·∫øu c√≥ jQuery/Bootstrap 4
          $("#authModal").modal("show");
        } else {
          alert("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng chat!");
        }
        return;
      }

      // Ki·ªÉm tra role ADMIN
      try {
        const user = JSON.parse(userData);
        let roles = user.roles;
        // N·∫øu roles ch∆∞a c√≥, parse t·ª´ accessToken (gi·ªëng main.js)
        if (!Array.isArray(roles) || roles.length === 0) {
          const payload = parseJwt(accessToken);
          roles = extractRolesFromPayload(payload);
        }
        if (
          roles &&
          roles.some(
            (r) =>
              r === "ADMIN" ||
              r === "ROLE_ADMIN" ||
              r === "MANAGER" ||
              r === "ROLE_MANAGER"
          )
        ) {
          // Chuy·ªÉn h∆∞·ªõng admin ƒë·∫øn trang chat-list (ƒë·ªìng b·ªô controller)
          window.location.href = "/api/admin/websocket/chat-list";
          return;
        }
      } catch (e) {
        /* ignore */
      }

      const box = document.getElementById("chatBox");
      if (!box) return;

      const isHidden = window.getComputedStyle(box).display === "none";

      closeAllChats(); // üî• ƒë√≥ng chatbot n·∫øu ƒëang m·ªü

      if (isHidden) {
        box.style.display = "flex";
        box.style.flexDirection = "column";
        // Reset unread count khi m·ªü chat box
        resetUnreadCount();
        showWelcomeMessage();
        if (!isConnected || !socket || socket.readyState !== WebSocket.OPEN) {
          // ƒê·∫£m b·∫£o WebSocket k·∫øt n·ªëi tr∆∞·ªõc khi hi·ªÉn th·ªã chat
          connectWebSocket().catch(err => {
            console.error("Failed to connect WebSocket:", err);
            alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi chat. Vui l√≤ng th·ª≠ l·∫°i.");
          });
        }
      }
    }

    // Helper parseJwt v√† extractRolesFromPayload gi·ªëng main.js
    function parseJwt(token) {
      try {
        const base64Url = token.split(".")[1];
        const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
        const jsonPayload = decodeURIComponent(
          atob(base64)
            .split("")
            .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
            .join("")
        );
        return JSON.parse(jsonPayload);
      } catch (_) {
        return {};
      }
    }
    function extractRolesFromPayload(payload) {
      if (!payload) return [];
      if (Array.isArray(payload.authorities)) return payload.authorities;
      if (Array.isArray(payload.roles)) return payload.roles;
      if (typeof payload.authorities === "string") return [payload.authorities];
      if (typeof payload.roles === "string") return [payload.roles];
      return [];
    }

    async function connectWebSocket() {
      const accessToken = localStorage.getItem("access_token");
      const userData = localStorage.getItem("liora_user");
      
      // L·∫•y userId ƒë·ªÉ k·∫øt n·ªëi v√†o room c·ªßa ch√≠nh user ƒë√≥
      let userId = null;
      try {
        if (userData) {
          const user = JSON.parse(userData);
          // Th·ª≠ l·∫•y t·ª´ user object
          userId = user.userId || user.id || user.user_id;
        }
        
        // N·∫øu kh√¥ng c√≥ trong user object, th·ª≠ l·∫•y t·ª´ JWT token
        if (!userId && accessToken) {
          try {
            const payload = parseJwt(accessToken);
            // JWT c√≥ th·ªÉ c√≥ userId, id, ho·∫∑c sub l√† username
            userId = payload.userId || payload.id || payload.user_id;
            
            // N·∫øu v·∫´n kh√¥ng c√≥, th·ª≠ l·∫•y t·ª´ API
            if (!userId) {
              const meRes = await fetch('/users/myInfo', {
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${accessToken}`,
                  'Content-Type': 'application/json'
                }
              });
              if (meRes.ok) {
                const meData = await meRes.json();
                const me = meData.result || meData.data || meData;
                userId = me.userId || me.id;
                
                console.log("Got userId from API:", userId, me);
                
                // C·∫≠p nh·∫≠t l·∫°i localStorage v·ªõi userId v√† avatar
                if (userId) {
                  try {
                    const user = userData ? JSON.parse(userData) : {};
                    user.userId = userId;
                    // C·∫≠p nh·∫≠t avatar n·∫øu c√≥
                    if (me.avatar) {
                      user.avatar = me.avatar;
                    }
                    localStorage.setItem('liora_user', JSON.stringify(user));
                  } catch (e) {
                    console.error("Error updating localStorage:", e);
                  }
                }
              }
            }
          } catch (e) {
            console.error("Error getting userId from token/API:", e);
          }
        }
      } catch (e) {
        console.error("Error parsing user data for WebSocket:", e);
      }
      
      // B·∫Øt bu·ªôc ph·∫£i c√≥ userId ƒë·ªÉ k·∫øt n·ªëi (m·ªói user c√≥ room ri√™ng)
      if (!userId) {
        console.error("Cannot connect WebSocket: userId is required. User data:", userData);
        alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi chat. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.");
        return;
      }
      
      // S·ª≠ d·ª•ng userId l√†m room (m·ªói user c√≥ room ri√™ng)
      const roomId = String(userId);
      
      // L·∫•y hostname ƒë·ªông thay v√¨ hardcode localhost
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      let wsUrl = `${protocol}//${host}/ws/chat/${roomId}`;
      
      if (accessToken) {
        wsUrl += `?token=${encodeURIComponent(accessToken)}`;
      }
      
      console.log("Connecting to WebSocket:", wsUrl);
      
      // ƒê√≥ng connection c≈© n·∫øu c√≥
      if (socket && socket.readyState !== WebSocket.CLOSED) {
        socket.close();
      }
      
      socket = new WebSocket(wsUrl);

      socket.onopen = function () {
        isConnected = true;
        console.log("WebSocket connected successfully to room:", roomId);
        // ƒê·∫£m b·∫£o chat box hi·ªÉn th·ªã khi k·∫øt n·ªëi
        const box = document.getElementById("chatBox");
        if (box && window.getComputedStyle(box).display === "none") {
          box.style.display = "flex";
          box.style.flexDirection = "column";
        }
      };

      socket.onmessage = function (event) {
        const msgDiv = document.getElementById("chatContent");
        if (!msgDiv) return;
        
        const userData = localStorage.getItem("liora_user");
        let myId = null,
          myAvatar = null,
          myUsername = null;
        try {
          if (userData) {
            const user = JSON.parse(userData);
            // Th·ª≠ nhi·ªÅu c√°ch ƒë·ªÉ l·∫•y userId
            myId = user.userId || user.id || user.user_id || null;
            myAvatar = user.avatar || null;
            myUsername = user.username || user.userName || null;
          }
        } catch (e) {
          console.error("Error parsing user data:", e);
        }
        
        function renderMsg(m) {
          // T·∫°o unique ID cho message
          const msgId = m.id ? `msg_${m.id}` : `${m.type}_${m.senderId}_${m.content}_${m.timestamp}`;
          
          // So s√°nh b·∫±ng userId ho·∫∑c username ƒë·ªÉ x√°c ƒë·ªãnh tin nh·∫Øn c·ªßa m√¨nh
          let isMine = false;
          if (myId && m.senderId) {
            isMine = String(m.senderId) === String(myId);
          } else if (myUsername && m.senderName) {
            isMine = String(m.senderName).toLowerCase() === String(myUsername).toLowerCase();
          }
          if (m.type === "CHAT") {
            if (isMine) {
              // My message - right side (kh√¥ng hi·ªÉn th·ªã avatar)
              return `<div class="message-item" data-msg-id="${msgId}" data-sender-id="${m.senderId || ''}" data-content="${(m.content || '').replace(/"/g, '&quot;')}" style="display:flex; justify-content:flex-end; align-items:flex-end; gap:8px;">
                <div style="max-width:75%; background:linear-gradient(135deg, #d78da0 0%, #e8a2b0 100%); color:#fff; border-radius:18px 18px 4px 18px; padding:12px 16px; box-shadow:0 2px 8px rgba(215, 141, 160, 0.2);">
                  <div style="font-size:0.95rem; line-height:1.5; word-wrap:break-word;">${m.content || ''}</div>
                  ${m.timestamp ? `<div data-timestamp="${m.timestamp}" style="font-size:0.7rem; opacity:0.8; margin-top:6px; text-align:right;">${formatTime(m.timestamp)}</div>` : ''}
                </div>
              </div>`;
            } else {
              // Other's message - left side
              const avatarUrl = m.avatar || '/user/img/default-product.jpg';
              const initial = m.senderName ? m.senderName[0].toUpperCase() : '?';
              return `<div class="message-item" data-msg-id="${msgId}" data-sender-id="${m.senderId || ''}" data-content="${(m.content || '').replace(/"/g, '&quot;')}" style="display:flex; align-items:flex-end; gap:8px; justify-content:flex-start;">
                <img 
                  src="${avatarUrl}" 
                  style="width:32px;height:32px;border-radius:50%;object-fit:cover;border:2px solid #f5d7db;flex-shrink:0;"
                  onerror="this.src='/user/img/default-product.jpg'"
                />
                <div style="max-width:75%; background:#fff; border:1px solid #f5d7db; color:#333; border-radius:18px 18px 18px 4px; padding:12px 16px; box-shadow:0 2px 8px rgba(0,0,0,0.05);">
                  <div style="font-weight:600; color:#d78da0; font-size:0.85rem; margin-bottom:4px;">${m.senderName || 'User'}</div>
                  <div style="font-size:0.95rem; line-height:1.5; word-wrap:break-word; color:#333;">${m.content || ''}</div>
                  ${m.timestamp ? `<div data-timestamp="${m.timestamp}" style="font-size:0.7rem; opacity:0.6; margin-top:6px; color:#666;">${formatTime(m.timestamp)}</div>` : ''}
                </div>
              </div>`;
            }
          } else if (m.type === "JOIN") {
            // T·∫Øt hi·ªÉn th·ªã th√¥ng b√°o JOIN
            return "";
          }
          return "";
        }
        
        function formatTime(timestamp) {
          if (!timestamp) return '';
          try {
            const date = new Date(timestamp);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            return `${hours}:${minutes} ${day}/${month}`;
          } catch (e) {
            return '';
          }
        }
        try {
          const msg = JSON.parse(event.data);
          console.log("Received WebSocket message:", msg); // Debug log
          
          if (msg.type === "CHAT") {
            // T·∫°o unique ID cho message - CH·ªà d√πng DB ID n·∫øu c√≥
            const msgId = msg.id ? `msg_${msg.id}` : null;
            
            // C√ÅCH M·ªöI: Ch·ªâ render n·∫øu c√≥ DB ID v√† ch∆∞a render, ho·∫∑c kh√¥ng c√≥ DB ID th√¨ ki·ªÉm tra k·ªπ h∆°n
            let shouldRender = false;
            
            if (msg.type === "CHAT") {
              // N·∫øu c√≥ DB ID (message ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o database)
              if (msg.id) {
                // Ki·ªÉm tra xem ƒë√£ render ch∆∞a
                if (!renderedMessageIds.has(`msg_${msg.id}`)) {
                  // Ki·ªÉm tra trong DOM xem ƒë√£ c√≥ ch∆∞a
                  const existingInDOM = msgDiv.querySelector(`[data-msg-id="msg_${msg.id}"]`);
                  if (!existingInDOM) {
                    shouldRender = true;
                  } else {
                    console.log("Message already in DOM:", msg.id);
                  }
                } else {
                  console.log("Message already in tracking Set:", msg.id);
                }
              } else {
                // N·∫øu kh√¥ng c√≥ DB ID (message ch∆∞a ƒë∆∞·ª£c l∆∞u), ki·ªÉm tra k·ªπ h∆°n
                // T·∫°o temporary ID t·ª´ content + senderId + timestamp
                const tempId = `${msg.senderId}_${msg.content}_${msg.timestamp}`;
                
                // Ki·ªÉm tra trong DOM xem ƒë√£ c√≥ message v·ªõi c√πng content, senderId v√† timestamp g·∫ßn nhau ch∆∞a
                const allMessages = msgDiv.querySelectorAll('.message-item[data-content]');
                let foundSimilar = false;
                
                for (let msgEl of allMessages) {
                  const existingContent = msgEl.getAttribute('data-content');
                  const existingSenderId = msgEl.getAttribute('data-sender-id');
                  
                  if (existingContent === msg.content && 
                      existingSenderId === String(msg.senderId || '')) {
                    // Ki·ªÉm tra timestamp
                    const existingTime = msgEl.querySelector('[data-timestamp]');
                    if (existingTime && msg.timestamp) {
                      const existingTimestamp = existingTime.getAttribute('data-timestamp');
                      const timeDiff = Math.abs(new Date(msg.timestamp).getTime() - new Date(existingTimestamp).getTime());
                      // N·∫øu timestamp kh√°c nhau < 3 gi√¢y, coi nh∆∞ duplicate
                      if (timeDiff < 3000) {
                        foundSimilar = true;
                        break;
                      }
                    } else {
                      // N·∫øu kh√¥ng c√≥ timestamp, coi nh∆∞ duplicate n·∫øu content v√† senderId gi·ªëng
                      foundSimilar = true;
                      break;
                    }
                  }
                }
                
                if (!foundSimilar && !renderedMessageIds.has(tempId)) {
                  shouldRender = true;
                  renderedMessageIds.add(tempId);
                }
              }
            } else if (msg.type === "JOIN") {
              // T·∫Øt hi·ªÉn th·ªã th√¥ng b√°o JOIN
              return;
            }
            
            // Render message n·∫øu ƒë∆∞·ª£c ph√©p
            if (shouldRender) {
              // ƒê√°nh d·∫•u ƒë√£ render b·∫±ng DB ID n·∫øu c√≥
              if (msg.id) {
                renderedMessageIds.add(`msg_${msg.id}`);
              }
              
              // Gi·ªõi h·∫°n size c·ªßa Set
              if (renderedMessageIds.size > 200) {
                // X√≥a 50 ph·∫ßn t·ª≠ c≈© nh·∫•t
                const idsArray = Array.from(renderedMessageIds);
                for (let i = 0; i < 50; i++) {
                  renderedMessageIds.delete(idsArray[i]);
                }
              }
              
              const renderedMsg = renderMsg(msg);
              if (renderedMsg) {
                msgDiv.insertAdjacentHTML("beforeend", renderedMsg);
                setTimeout(() => {
                  msgDiv.scrollTop = msgDiv.scrollHeight;
                }, 50);
                
                // TƒÉng unread count n·∫øu chat box ƒëang ƒë√≥ng v√† tin nh·∫Øn kh√¥ng ph·∫£i t·ª´ ch√≠nh user
                const chatBox = document.getElementById("chatBox");
                const isChatBoxOpen = chatBox && window.getComputedStyle(chatBox).display !== "none";
                if (!isChatBoxOpen) {
                  // Ki·ªÉm tra xem tin nh·∫Øn c√≥ ph·∫£i t·ª´ ch√≠nh user kh√¥ng
                  let isMine = false;
                  if (myId && msg.senderId) {
                    isMine = String(msg.senderId) === String(myId);
                  } else if (myUsername && msg.senderName) {
                    isMine = String(msg.senderName).toLowerCase() === String(myUsername).toLowerCase();
                  }
                  // Ch·ªâ tƒÉng unread count n·∫øu tin nh·∫Øn kh√¥ng ph·∫£i t·ª´ ch√≠nh user
                  if (!isMine) {
                    incrementUnreadCount();
                  }
                }
              }
            } else {
              console.log("Skipping duplicate message:", msg);
            }
          } else if (msg.type === "HISTORY" && Array.isArray(msg.messages)) {
            // Clear existing messages first
            msgDiv.innerHTML = '';
            renderedMessageIds.clear(); // Clear tracking khi load history
            pendingMessages.clear(); // Clear pending messages
            
            // Reverse ƒë·ªÉ hi·ªÉn th·ªã t·ª´ c≈© ƒë·∫øn m·ªõi (oldest first)
            const reversedMessages = [...msg.messages].reverse();
            reversedMessages.forEach((m) => {
              // T·∫°o unique ID cho m·ªói message trong history (s·ª≠ d·ª•ng format gi·ªëng v·ªõi CHAT messages)
              const msgId = m.id ? `msg_${m.id}` : `${m.type || 'CHAT'}_${m.senderId}_${m.content}_${m.timestamp}`;
              if (!renderedMessageIds.has(msgId)) {
                renderedMessageIds.add(msgId);
                const renderedMsg = renderMsg(m);
                if (renderedMsg) {
                  msgDiv.insertAdjacentHTML("beforeend", renderedMsg);
                }
              }
            });
            // Scroll to bottom after loading all history (newest messages)
            setTimeout(() => {
              msgDiv.scrollTop = msgDiv.scrollHeight;
            }, 200);
          }
        } catch (e) {
          console.error("Error parsing message:", e, event.data);
          msgDiv.insertAdjacentHTML(
            "beforeend",
            `<div class="message-item" style='margin-bottom:12px; padding:12px; background:#fff; border-radius:12px; color:#666;'>${event.data}</div>`
          );
          setTimeout(() => {
            msgDiv.scrollTop = msgDiv.scrollHeight;
          }, 50);
        }
      };

      socket.onerror = function (error) {
        console.error("WebSocket error:", error);
        isConnected = false;
      };

      socket.onclose = function (event) {
        isConnected = false;
        console.log("WebSocket closed", event.code, event.reason);
        // T·ª± ƒë·ªông reconnect sau 3 gi√¢y n·∫øu b·ªã ƒë√≥ng kh√¥ng mong mu·ªën
        if (event.code !== 1000) {
          setTimeout(() => {
            if (document.getElementById("chatBox") && 
                window.getComputedStyle(document.getElementById("chatBox")).display !== "none") {
              console.log("Attempting to reconnect...");
              connectWebSocket();
            }
          }, 3000);
        }
      };
    }

    function showWelcomeMessage() {
      if (hasShownWelcome) return;

      const msgDiv = document.getElementById("chatContent");
      if (!msgDiv) return;
      
      msgDiv.insertAdjacentHTML(
        "beforeend",
        `<div class="message-item" style="margin-bottom:12px; background:linear-gradient(135deg, #fdecef 0%, #fce8ed 100%); padding:16px; border-radius:18px; color:#b85c7a; border-left:4px solid #d78da0; box-shadow:0 2px 8px rgba(215, 141, 160, 0.1);">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
              <div style="width:32px;height:32px;border-radius:50%;background:linear-gradient(135deg, #d78da0 0%, #e8a2b0 100%);display:flex;align-items:center;justify-content:center;color:white;font-size:1.2rem;">üå∏</div>
              <div style="font-weight:700; font-size:1rem;">Liora CSKH</div>
            </div>
            <div style="font-size:0.95rem; line-height:1.6;">
              Liora xin ch√†o! B·∫°n c·∫ßn t√¨m s·∫£n ph·∫©m cho b√© hay cho m·∫π ·∫°? Ch√∫ng t√¥i s·∫µn s√†ng h·ªó tr·ª£ b·∫°n! üíï
            </div>
        </div>`
      );
      // Scroll to bottom after welcome message
      setTimeout(() => {
        if (msgDiv) {
          msgDiv.scrollTop = msgDiv.scrollHeight;
        }
      }, 100);
      hasShownWelcome = true;
    }
    async function sendMessage() {
      const input = document.getElementById("chatInput");
      const msgDiv = document.getElementById("chatContent");
      
      if (!input || !msgDiv) return;
      
      const messageText = input.value.trim();
      if (!messageText) return;
      
      // L·∫•y th√¥ng tin user ƒë·ªÉ hi·ªÉn th·ªã tin nh·∫Øn ngay
      const userData = localStorage.getItem("liora_user");
      let myId = null, myAvatar = null, myUsername = null;
      try {
        if (userData) {
          const user = JSON.parse(userData);
          myId = user.userId || user.id || user.user_id || null;
          myAvatar = user.avatar || null;
          myUsername = user.username || user.userName || null;
        }
      } catch (e) {}
      
      // Ki·ªÉm tra v√† ƒë·∫£m b·∫£o WebSocket ƒë√£ k·∫øt n·ªëi
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not connected, attempting to connect...");
        await connectWebSocket();
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ WebSocket k·∫øt n·ªëi
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Ki·ªÉm tra l·∫°i
        if (!socket || socket.readyState !== WebSocket.OPEN) {
          alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi chat. Vui l√≤ng th·ª≠ l·∫°i sau.");
          return;
        }
      }
      
      try {
        // KH√îNG render optimistic update n·ªØa - ch·ªâ g·ª≠i v√† ƒë·ª£i server response
        // T·∫°o key ƒë·ªÉ track message ƒëang ch·ªù
        const pendingKey = `${messageText}_${Date.now()}`;
        
        // G·ª≠i qua WebSocket
        socket.send(JSON.stringify({ content: messageText }));
        input.value = "";
        
        // Focus l·∫°i input sau khi g·ª≠i
        setTimeout(() => {
          input.focus();
        }, 50);
        
        // Timeout sau 5 gi√¢y n·∫øu kh√¥ng nh·∫≠n ƒë∆∞·ª£c response t·ª´ server
        setTimeout(() => {
          if (pendingMessages.has(pendingKey)) {
            pendingMessages.delete(pendingKey);
          }
        }, 5000);
      } catch (e) {
        console.error("Error sending message:", e);
        alert("C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.");
      }
    }
    
    function formatTime(timestamp) {
      if (!timestamp) return '';
      try {
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        return `${hours}:${minutes} ${day}/${month}`;
      } catch (e) {
        return '';
      }
    }

    function closeAllChats() {
      const chatbot = document.querySelector(".chatbot-window");
      const chatWs = document.getElementById("chatBox");

      if (chatbot) chatbot.style.display = "none";
      if (chatWs) chatWs.style.display = "none";
    }

    function closeChatWS() {
      const box = document.getElementById("chatBox");
      if (box) box.style.display = "none";
    }
  </script>
</div>
